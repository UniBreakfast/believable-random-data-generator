// these are the very primitive functions for semi-manual analysis of simple
// data structures generated by my random functions and alike


// replace body with minimalistic barChart illustrating the proportions given
const visualize = (data, options={}) => {
  // in case it's an object make a nested array of pairs of it
  if ( !Array.isArray(data) )  data = Object.entries(data)

  // sort if possible, if not - it's fine
  try { data = data.sort( (a, b) => a[0] - b[0] ) } catch {}

  const { width=1080, namesWidth=80, barMaxWidth=1000, height=700,
          barHeight = Math.max(10, height/data.length-1) } = options,

        maxNum = Math.max( ...data.map(row => row[1]) ),

        unitSize = barMaxWidth / maxNum, // size in pixels per 1 thing
        calcWidth = (num) => Math.floor(num * unitSize),

        unitColor = 256 / maxNum,       // HUE color shift per 1 thing
        calcColor = (num) => Math.floor(256 - num * unitColor),

        style = `<style>
                   body>div {
                     display: grid;
                     width: ${ width }px;
                     grid-template-columns: ${ namesWidth }px auto;
                     gap: 1px;
                   }
                   body>div>span:nth-child(odd) {
                     text-align: right;
                     padding-right: 5px;
                     line-height: ${ barHeight }px;
                     font-weight: bold;
                   }
                   body>div>span:nth-child(even) {
                     height: ${ barHeight }px;
                     border-radius: 6px;
                   }
                 </style>`

  const bars = data.reduce( (html, [valueName, number]) =>
    html + `<span title=${ number }>${ valueName }</span> <span
      title=${ number } style="background:hsl(${ calcColor(number) },74%,45%);
        width:${ calcWidth(number) }"></span>`, '')

  // I know, it's like a style "on a duct tape" solution, but here it's ok
  document.body.innerHTML = style + `<div> ${ bars } </div>`
}


// it's for the quick checking a possible result sets of functions with rnd
const probe = (given, options={}) => {
  // it's ready for two presenter-functions: visualise and quickTable
  const { presenter=visualize, num=10000 } = options

  if (typeof given == 'function') {     // in case the function is given...
    // if it produces the array - that's what it works on further on
    if ( Array.isArray(given()) )  given = given()
    // otherwise (it should produce a primitive value) make an array of them
    else  given = makeArr(num, given)                   // ... of num length
  }

  // if an array of values is ready at this point count unique values in it
  if ( Array.isArray(given) )  given = countUnique(given)

  presenter(given, options)  // now the object should be ready to present
}


// I use this to copy columns of data for pasting them into the spreadsheets
const quickTable = (data) => {
  // in case it's an object make a nested array of pairs of it
  if ( !Array.isArray(data) )  data = Object.entries(data)

  // sort if possible, if not - it's fine
  try { data = data.sort( (a, b) => a[0] - b[0] ) } catch {}

  let trs = data.reduce( (trs, row)=>
          trs + `<tr> <th>${ row[0] }</th> <td>${ row[1] }</td> </tr>`, '')

  // and of course the body shouldn't be replaced just to show a small table :)
  document.body.innerHTML = `<table border=1> ${ trs } </table>`
}


// like the probe function above, just preloaded with the quickTable presenter
const probeTbl = (given, options) =>
                          probe(given, {...options, presenter: quickTable})
